{
    "assignment": {
        "active": true,
        "autograding_enabled": false,
        "autograding_key": "",
        "course": {
            "active": true,
            "created": "2015-08-24 20:37:42.000000",
            "display_name": "CS 61A",
            "id": 5631829415559168,
            "institution": "UC Berkeley",
            "instructor": [],
            "offering": "cal/cs61a/fa15"
        },
        "created": "2015-10-06 15:04:15.703590",
        "creator": {
            "created": "2015-01-24 09:31:51.000000",
            "email": [
                "denero@berkeley.edu"
            ],
            "id": 5937555576979456,
            "is_admin": true
        },
        "display_name": "Ants",
        "due_date": "2015-10-16 23:59:59.000000",
        "id": 5474163168903168,
        "lock_date": "2015-10-20 23:59:59.000000",
        "max_group_size": 2,
        "name": "cal/cs61a/fa15/proj3",
        "points": 25.0,
        "revision": false,
        "templates": "{}",
        "url": "cs61a.org/proj/ants"
    },
    "client_time": null,
    "created": "2015-10-12 19:49:39.977750",
    "id": 5323925271609344,
    "messages": {
        "analytics": {
            "started": {
                "Problem 1": true,
                "Problem 2": true,
                "Problem 3A": true,
                "Problem 3B": true,
                "Problem 4A": true,
                "Problem 4B": true,
                "Problem 5A": true,
                "Problem 5B": true,
                "Problem 6A": true,
                "Problem 6B": true,
                "Problem 7": true,
                "Problem 8": true,
                "Problem 9": true,
                "Problem EC": true
            },
            "time": "2015-10-12 19:49:39.977750",
            "unlock": false
        },
        "file_contents": {
            "ants.py": "\"\"\"The ants module implements game logic for Ants Vs. SomeBees.\"\"\"\n\nimport random\nimport sys\nfrom ucb import main, interact, trace\nfrom collections import OrderedDict\n\n\n################\n# Core Classes #\n################\n\nclass Place(object):\n    \"\"\"A Place holds insects and has an exit to another Place.\"\"\"\n\n    def __init__(self, name, exit=None):\n        \"\"\"Create a Place with the given exit.\n\n        name -- A string; the name of this Place.\n        exit -- The Place reached by exiting this Place (may be None).\n        \"\"\"\n        self.name = name\n        self.exit = exit\n        self.bees = []        # A list of Bees\n        self.ant = None       # An Ant\n        self.entrance = None  # A Place\n        # Phase 1: Add an entrance to the exit\n        # BEGIN Problem 2\n        if exit:\n            exit.entrance = self\n        # END Problem 2\n\n    def add_insect(self, insect):\n        \"\"\"Add an Insect to this Place.\n\n        There can be at most one Ant in a Place, unless exactly one of them is\n        a BodyguardAnt (Phase 4), in which case there can be two. If add_insect\n        tries to add more Ants than is allowed, an assertion error is raised.\n\n        There can be any number of Bees in a Place.\n        \"\"\"\n        if insect.is_ant:\n            if self.ant is None:\n                self.ant = insect\n            else:\n                # Phase 4: Special handling for BodyguardAnt\n                # BEGIN Problem 7\n                if self.ant.can_contain(insect):\n                    self.ant.contain_ant(insect)\n                elif insect.can_contain(self.ant):\n                    insect.contain_ant(self.ant)\n                    self.ant = insect\n                else:\n                    assert self.ant is None or not self.ant.container, 'Two ants in {0}'.format(self)\n                # END Problem 7\n        else:\n            self.bees.append(insect)\n        insect.place = self\n\n    def remove_insect(self, insect):\n        \"\"\"Remove an Insect from this Place.\n\n        A target Ant may either be directly in the Place, or be contained by a\n        container Ant at this place. The true QueenAnt may not be removed. If\n        remove_insect tries to remove an Ant that is not anywhere in this\n        Place, an AssertionError is raised.\n\n        A Bee is just removed from the list of Bees.\n        \"\"\"\n        if insect.is_ant:\n            # Phase 4: Special Handling for BodyguardAnt and QueenAnt\n            if self.ant is insect:\n                if hasattr(self.ant, 'container') and self.ant.container:\n                    self.ant = self.ant.ant\n                elif type(self.ant) != QueenAnt or self.ant.impostor:\n                    self.ant = None\n            else:\n                if hasattr(self.ant, 'container') and self.ant.container and self.ant.ant is insect:\n                    if type(self.ant.ant) != QueenAnt or self.ant.ant.impostor:\n                        self.ant.ant = None\n                else:\n                    assert False, '{0} is not in {1}'.format(insect, self)\n        else:\n            self.bees.remove(insect)\n\n        if type(insect) != QueenAnt or insect.impostor:\n            insect.place = None\n\n    def __str__(self):\n        return self.name\n\n\nclass Insect(object):\n    \"\"\"An Insect, the base class of Ant and Bee, has armor and a Place.\"\"\"\n\n    is_ant = False\n    damage = 0\n    watersafe = False\n\n    def __init__(self, armor, place=None):\n        \"\"\"Create an Insect with an armor amount and a starting Place.\"\"\"\n        self.armor = armor\n        self.place = place  # set by Place.add_insect and Place.remove_insect\n\n    def reduce_armor(self, amount):\n        \"\"\"Reduce armor by amount, and remove the insect from its place if it\n        has no armor remaining.\n\n        >>> test_insect = Insect(5)\n        >>> test_insect.reduce_armor(2)\n        >>> test_insect.armor\n        3\n        \"\"\"\n        self.armor -= amount\n        if self.armor <= 0:\n            self.place.remove_insect(self)\n\n    def action(self, colony):\n        \"\"\"The action performed each turn.\n\n        colony -- The AntColony, used to access game state information.\n        \"\"\"\n\n    def __repr__(self):\n        cname = type(self).__name__\n        return '{0}({1}, {2})'.format(cname, self.armor, self.place)\n\n\nclass Bee(Insect):\n    \"\"\"A Bee moves from place to place, following exits and stinging ants.\"\"\"\n\n    name = 'Bee'\n    damage = 1\n    watersafe = True\n\n    def sting(self, ant):\n        \"\"\"Attack an Ant, reducing the Ant's armor by 1.\"\"\"\n        ant.reduce_armor(self.damage)\n\n    def move_to(self, place):\n        \"\"\"Move from the Bee's current Place to a new Place.\"\"\"\n        self.place.remove_insect(self)\n        place.add_insect(self)\n\n    def blocked(self):\n        \"\"\"Return True if this Bee cannot advance to the next Place.\"\"\"\n        # Phase 3: Special handling for NinjaAnt\n        # BEGIN Problem 6A\n        return self.place.ant and self.place.ant.blocks_path\n        # END Problem 6A\n\n    def action(self, colony):\n        \"\"\"A Bee's action stings the Ant that blocks its exit if it is blocked,\n        or moves to the exit of its current place otherwise.\n\n        colony -- The AntColony, used to access game state information.\n        \"\"\"\n        if self.blocked():\n            self.sting(self.place.ant)\n        elif self.armor > 0 and self.place.exit is not None:\n            self.move_to(self.place.exit)\n\n\nclass Ant(Insect):\n    \"\"\"An Ant occupies a place and does work for the colony.\"\"\"\n\n    is_ant = True\n    implemented = False  # Only implemented Ant classes should be instantiated\n    food_cost = 0\n    blocks_path = True\n    container = False\n\n    def __init__(self, armor=1):\n        \"\"\"Create an Ant with an armor quantity.\"\"\"\n        Insect.__init__(self, armor)\n\n    def can_contain(self, other):\n        return self.container and not self.ant and not other.container\n\n\nclass HarvesterAnt(Ant):\n    \"\"\"HarvesterAnt produces 1 additional food per turn for the colony.\"\"\"\n\n    name = 'Harvester'\n    implemented = True\n    food_cost = 2\n\n    def action(self, colony):\n        \"\"\"Produce 1 additional food for the colony.\n\n        colony -- The AntColony, used to access game state information.\n        \"\"\"\n        # BEGIN Problem 1\n        colony.food += 1\n        # END Problem 1\n\n\nclass ThrowerAnt(Ant):\n    \"\"\"ThrowerAnt throws a leaf each turn at the nearest Bee in its range.\"\"\"\n\n    name = 'Thrower'\n    implemented = True\n    damage = 1\n    food_cost = 4\n    min_range = 0\n    max_range = 100000\n\n    def nearest_bee(self, hive):\n        \"\"\"Return the nearest Bee in a Place that is not the Hive, connected to\n        the ThrowerAnt's Place by following entrances.\n\n        This method returns None if there is no such Bee (or none in range).\n        \"\"\"\n        # BEGIN Problem 3B\n        \"*** REPLACE THIS LINE ***\"\n        place = self.place\n        counter = 0\n        while place != hive:\n            if place.bees and counter >= self.min_range and counter <= self.max_range:\n                return random_or_none(place.bees)\n            place = place.entrance\n            counter += 1\n        return None\n        # END Problem 3B\n\n    def throw_at(self, target):\n        \"\"\"Throw a leaf at the target Bee, reducing its armor.\"\"\"\n        if target is not None:\n            target.reduce_armor(self.damage)\n\n    def action(self, colony):\n        \"\"\"Throw a leaf at the nearest Bee in range.\"\"\"\n        self.throw_at(self.nearest_bee(colony.hive))\n\ndef random_or_none(s):\n    \"\"\"Return a random element of sequence s, or return None if s is empty.\"\"\"\n    if s:\n        return random.choice(s)\n\n\n##############\n# Extensions #\n##############\n\nclass Water(Place):\n    \"\"\"Water is a place that can only hold 'watersafe' insects.\"\"\"\n\n    def add_insect(self, insect):\n        \"\"\"Add insect if it is watersafe, otherwise reduce its armor to 0.\"\"\"\n        # BEGIN Problem 3A\n        Place.add_insect(self, insect)\n        if not insect.watersafe:\n            insect.reduce_armor(insect.armor)\n        # END Problem 3A\n\n\nclass FireAnt(Ant):\n    \"\"\"FireAnt cooks any Bee in its Place when it expires.\"\"\"\n\n    name = 'Fire'\n    damage = 3\n    # BEGIN Problem 4A\n    food_cost = 6\n    implemented = True   # Change to True to view in the GUI\n    # END Problem 4A\n\n    def reduce_armor(self, amount):\n        # BEGIN Problem 4A\n        if amount >= self.armor:\n            for bee in self.place.bees[:]:\n                bee.reduce_armor(self.damage)\n        Insect.reduce_armor(self, amount)\n        # END Problem 4A\n\n\nclass LongThrower(ThrowerAnt):\n    \"\"\"A ThrowerAnt that only throws leaves at Bees at least 5 places away.\"\"\"\n\n    name = 'Long'\n    # BEGIN Problem 4B\n    food_cost = 2\n    min_range = 5\n    implemented = True   # Change to True to view in the GUI\n    # END Problem 4B\n\n\n\nclass ShortThrower(ThrowerAnt):\n    \"\"\"A ThrowerAnt that only throws leaves at Bees at most 3 places away.\"\"\"\n\n    name = 'Short'\n    # BEGIN Problem 4B\n    food_cost = 2\n    max_range = 3\n    implemented = True   # Change to True to view in the GUI\n    # END Problem 4B\n\n\n# BEGIN Problem 5A\nclass WallAnt(Ant):\n    name = 'Wall'\n    food_cost = 4\n    implemented = True\n\n    def __init__(self, armor = 4):\n        self.armor = armor\n# The WallAnt class\n# END Problem 5A\n\n\nclass NinjaAnt(Ant):\n    \"\"\"NinjaAnt does not block the path and damages all bees in its place.\"\"\"\n\n    name = 'Ninja'\n    damage = 1\n    # BEGIN Problem 6A\n    food_cost = 6\n    blocks_path = False\n    implemented = True   # Change to True to view in the GUI\n    # END Problem 6A\n\n    def action(self, colony):\n        # BEGIN Problem 6A\n        for bee in self.place.bees[:]:\n            bee.reduce_armor(self.damage)\n        # END Problem 6A\n\n\n# BEGIN Problem 5B\nclass ScubaThrower(ThrowerAnt):\n    name = 'Scuba'\n    food_cost = 5\n    implemented = True\n    watersafe = True\n# The ScubaThrower class\n# END Problem 5B\n\n\nclass HungryAnt(Ant):\n    \"\"\"HungryAnt will take three turns to digest a Bee in its place.\n    While digesting, the HungryAnt can't eat another Bee.\n    \"\"\"\n    name = 'Hungry'\n    # BEGIN Problem 6B\n    food_cost = 4\n    time_to_digest = 3\n    implemented = True   # Change to True to view in the GUI\n    # END Problem 6B\n\n    def __init__(self):\n        # BEGIN Problem 6B\n        Ant.__init__(self, 1)\n        self.digesting = 0\n        # END Problem 6B\n\n    def eat_bee(self, bee):\n        # BEGIN Problem 6B\n        if bee:\n            bee.reduce_armor(bee.armor)\n        # END Problem 6B\n\n    def action(self, colony):\n        # BEGIN Problem 6B\n        if self.digesting > 0:\n            self.digesting -= 1\n        else:\n            bee = random_or_none(self.place.bees)\n            if bee:\n                self.eat_bee(bee)\n                self.digesting = self.time_to_digest\n        # END Problem 6B\n\n\nclass BodyguardAnt(Ant):\n    \"\"\"BodyguardAnt provides protection to other Ants.\"\"\"\n    name = 'Bodyguard'\n    # BEGIN Problem 7\n    food_cost = 4\n    container = True\n    implemented = True   # Change to True to view in the GUI\n    # END Problem 7\n\n    def __init__(self):\n        Ant.__init__(self, 2)\n        self.ant = None  # The Ant hidden in this bodyguard\n\n    def contain_ant(self, ant):\n        # BEGIN Problem 7\n        self.ant = ant\n        # END Problem 7\n\n    def action(self, colony):\n        # BEGIN Problem 7\n        if self.ant:\n            self.ant.action(colony)\n        # END Problem 7\n\nclass TankAnt(BodyguardAnt):\n    \"\"\"TankAnt provides both offensive and defensive capabilities.\"\"\"\n    name = 'Tank'\n    damage = 1\n    # BEGIN Problem 8\n    food_cost = 6\n    container = True\n    implemented = True   # Change to True to view in the GUI\n    # END Problem 8\n\n    def action(self, colony):\n        # BEGIN Problem 8\n        BodyguardAnt.action(self, colony)\n        for bee in self.place.bees[:]:\n                bee.reduce_armor(self.damage)\n        # END Problem 8\n\nclass QueenAnt(ScubaThrower):  # You should change this line\n    \"\"\"The Queen of the colony.  The game is over if a bee enters her place.\"\"\"\n\n    name = 'Queen'\n    # BEGIN Problem 9\n    food_cost = 6\n    impostor = False\n    doubled = []\n    implemented = True   # Change to True to view in the GUI\n    # END Problem 9\n\n    def __init__(self):\n        # BEGIN Problem 9\n        Ant.__init__(self)\n        if not self.impostor:\n            QueenAnt.impostor = True\n            self.impostor = False\n        else:\n            self.damage = 0\n        self.doubled_ants = []\n        # END Problem 9\n\n    def action(self, colony):\n        \"\"\"A queen ant throws a leaf, but also doubles the damage of ants\n        in her tunnel.\n\n        Impostor queens do only one thing: reduce their own armor to 0.\n        \"\"\"\n        # BEGIN Problem 9\n        ThrowerAnt.action(self, colony)\n        if self.impostor:\n            self.reduce_armor(self.armor)\n        else:\n            place = self.place\n            while place.exit:\n                if place.ant and place.ant.name != 'Queen':\n                    if place.ant.container and place.ant.ant and place.ant.ant not in self.doubled_ants:\n                        place.ant.ant.damage *= 2\n                        self.doubled_ants += [place.ant.ant]\n                    elif place.ant not in self.doubled_ants:\n                        place.ant.damage *= 2\n                        self.doubled_ants += [place.ant]\n                place = place.exit\n        # END Problem 9\n\n    def reduce_armor(self, amount):\n        \"\"\"Reduce armor by amount, and if the True QueenAnt has no armor\n        remaining, signal the end of the game.\n        \"\"\"\n        # BEGIN Problem 9\n        if not self.impostor and amount >= self.armor:\n            Ant.reduce_armor(self, amount)\n            bees_win()\n        else:\n            Ant.reduce_armor(self, amount)\n        # END Problem 9\n\nclass AntRemover(Ant):\n    \"\"\"Allows the player to remove ants from the board in the GUI.\"\"\"\n\n    name = 'Remover'\n    implemented = False\n\n    def __init__(self):\n        Ant.__init__(self, 0)\n\n\n##################\n# Status Effects #\n##################\n\ndef make_slow(action):\n    \"\"\"Return a new action method that calls action every other turn.\n\n    action -- An action method of some Bee\n    \"\"\"\n    # BEGIN Problem EC\n    def new_action(self, colony):\n        if colony.time % 2 == 0:\n            action(self, colony)\n    return new_action\n    # END Problem EC\n\ndef make_stun(action):\n    \"\"\"Return a new action method that does nothing.\n\n    action -- An action method of some Bee\n    \"\"\"\n    # BEGIN Problem EC\n    def new_action(self, colony):\n        None\n    return new_action\n    # END Problem EC\n\ndef apply_effect(effect, bee, duration):\n    \"\"\"Apply a status effect to a Bee that lasts for duration turns.\"\"\"\n    # BEGIN Problem EC\n    action = bee.action\n    while duration > 0:\n        \"object.__setattr__(bee, 'action', effect(Bee.action))\"\n        bee.action = effect(action)\n        duration -= 1\n    \"object.__setattr__(bee, 'action', Bee.action)\"\n    bee.action = action\n    # END Problem EC\n\n\nclass SlowThrower(ThrowerAnt):\n    \"\"\"ThrowerAnt that causes Slow on Bees.\"\"\"\n\n    name = 'Slow'\n    # BEGIN Problem EC\n    food_cost = 4\n    implemented = False   # Change to True to view in the GUI\n    # END Problem EC\n\n    def throw_at(self, target):\n        if target:\n            apply_effect(make_slow, target, 3)\n\n\nclass StunThrower(ThrowerAnt):\n    \"\"\"ThrowerAnt that causes Stun on Bees.\"\"\"\n\n    name = 'Stun'\n    # BEGIN Problem EC\n    food_cost = 6\n    implemented = False   # Change to True to view in the GUI\n    # END Problem EC\n\n    def throw_at(self, target):\n        if target:\n            apply_effect(make_stun, target, 1)\n\n\n##################\n# Bees Extension #\n##################\n\nclass Wasp(Bee):\n    \"\"\"Class of Bee that has higher damage.\"\"\"\n    name = 'Wasp'\n    damage = 2\n\nclass Hornet(Bee):\n    \"\"\"Class of bee that is capable of taking two actions per turn, although\n    its overall damage output is lower. Immune to status effects.\n    \"\"\"\n    name = 'Hornet'\n    damage = 0.25\n\n    def action(self, colony):\n        for i in range(2):\n            if self.armor > 0:\n                super().action(colony)\n\n    def __setattr__(self, name, value):\n        if name != 'action':\n            object.__setattr__(self, name, value)\n\nclass NinjaBee(Bee):\n    \"\"\"A Bee that cannot be blocked. Is capable of moving past all defenses to\n    assassinate the Queen.\n    \"\"\"\n    name = 'NinjaBee'\n\n    def blocked(self):\n        return False\n\nclass Boss(Wasp, Hornet):\n    \"\"\"The leader of the bees. Combines the high damage of the Wasp along with\n    status effect immunity of Hornets. Damage to the boss is capped up to 8\n    damage by a single attack.\n    \"\"\"\n    name = 'Boss'\n    damage_cap = 8\n    action = Wasp.action\n\n    def reduce_armor(self, amount):\n        super().reduce_armor(self.damage_modifier(amount))\n\n    def damage_modifier(self, amount):\n        return amount * self.damage_cap/(self.damage_cap + amount)\n\nclass Hive(Place):\n    \"\"\"The Place from which the Bees launch their assault.\n\n    assault_plan -- An AssaultPlan; when & where bees enter the colony.\n    \"\"\"\n\n    def __init__(self, assault_plan):\n        self.name = 'Hive'\n        self.assault_plan = assault_plan\n        self.bees = []\n        for bee in assault_plan.all_bees:\n            self.add_insect(bee)\n        # The following attributes are always None for a Hive\n        self.entrance = None\n        self.ant = None\n        self.exit = None\n\n    def strategy(self, colony):\n        exits = [p for p in colony.places.values() if p.entrance is self]\n        for bee in self.assault_plan.get(colony.time, []):\n            bee.move_to(random.choice(exits))\n            colony.active_bees.append(bee)\n\n\nclass AntColony(object):\n    \"\"\"An ant collective that manages global game state and simulates time.\n\n    Attributes:\n    time -- elapsed time\n    food -- the colony's available food total\n    queen -- the place where the queen resides\n    places -- A list of all places in the colony (including a Hive)\n    bee_entrances -- A list of places that bees can enter\n    \"\"\"\n\n    def __init__(self, strategy, hive, ant_types, create_places, dimensions, food=2):\n        \"\"\"Create an AntColony for simulating a game.\n\n        Arguments:\n        strategy -- a function to deploy ants to places\n        hive -- a Hive full of bees\n        ant_types -- a list of ant constructors\n        create_places -- a function that creates the set of places\n        dimensions -- a pair containing the dimensions of the game layout\n        \"\"\"\n        self.time = 0\n        self.food = food\n        self.strategy = strategy\n        self.hive = hive\n        self.ant_types = OrderedDict((a.name, a) for a in ant_types)\n        self.dimensions = dimensions\n        self.active_bees = []\n        self.configure(hive, create_places)\n\n    def configure(self, hive, create_places):\n        \"\"\"Configure the places in the colony.\"\"\"\n        self.queen = QueenPlace('AntQueen')\n        self.places = OrderedDict()\n        self.bee_entrances = []\n        def register_place(place, is_bee_entrance):\n            self.places[place.name] = place\n            if is_bee_entrance:\n                place.entrance = hive\n                self.bee_entrances.append(place)\n        register_place(self.hive, False)\n        create_places(self.queen, register_place, self.dimensions[0], self.dimensions[1])\n\n    def simulate(self):\n        \"\"\"Simulate an attack on the ant colony (i.e., play the game).\"\"\"\n        num_bees = len(self.bees)\n        try:\n            while True:\n                self.hive.strategy(self)            # Bees invade\n                self.strategy(self)                 # Ants deploy\n                for ant in self.ants:               # Ants take actions\n                    if ant.armor > 0:\n                        ant.action(self)\n                for bee in self.active_bees[:]:     # Bees take actions\n                    if bee.armor > 0:\n                        bee.action(self)\n                    if bee.armor <= 0:\n                        num_bees -= 1\n                        self.active_bees.remove(bee)\n                if num_bees == 0:\n                    raise AntsWinException()\n                self.time += 1\n        except AntsWinException:\n            print('All bees are vanquished. You win!')\n            return True\n        except BeesWinException:\n            print('The ant queen has perished. Please try again.')\n            return False\n\n    def deploy_ant(self, place_name, ant_type_name):\n        \"\"\"Place an ant if enough food is available.\n\n        This method is called by the current strategy to deploy ants.\n        \"\"\"\n        constructor = self.ant_types[ant_type_name]\n        if self.food < constructor.food_cost:\n            print('Not enough food remains to place ' + ant_type_name)\n        else:\n            ant = constructor()\n            self.places[place_name].add_insect(ant)\n            self.food -= constructor.food_cost\n            return ant\n\n    def remove_ant(self, place_name):\n        \"\"\"Remove an Ant from the Colony.\"\"\"\n        place = self.places[place_name]\n        if place.ant is not None:\n            place.remove_insect(place.ant)\n\n    @property\n    def ants(self):\n        return [p.ant for p in self.places.values() if p.ant is not None]\n\n    @property\n    def bees(self):\n        return [b for p in self.places.values() for b in p.bees]\n\n    @property\n    def insects(self):\n        return self.ants + self.bees\n\n    def __str__(self):\n        status = ' (Food: {0}, Time: {1})'.format(self.food, self.time)\n        return str([str(i) for i in self.ants + self.bees]) + status\n\nclass QueenPlace(Place):\n    \"\"\"QueenPlace at the end of the tunnel, where the queen resides.\"\"\"\n\n    def add_insect(self, insect):\n        \"\"\"Add an Insect to this Place.\n\n        Can't actually add Ants to a QueenPlace. However, if a Bee attempts to\n        enter the QueenPlace, a BeesWinException is raised, signaling the end\n        of a game.\n        \"\"\"\n        assert not insect.is_ant, 'Cannot add {0} to QueenPlace'\n        raise BeesWinException()\n\ndef ants_win():\n    \"\"\"Signal that Ants win.\"\"\"\n    raise AntsWinException()\n\ndef bees_win():\n    \"\"\"Signal that Bees win.\"\"\"\n    raise BeesWinException()\n\ndef ant_types():\n    \"\"\"Return a list of all implemented Ant classes.\"\"\"\n    all_ant_types = []\n    new_types = [Ant]\n    while new_types:\n        new_types = [t for c in new_types for t in c.__subclasses__()]\n        all_ant_types.extend(new_types)\n    return [t for t in all_ant_types if t.implemented]\n\nclass GameOverException(Exception):\n    \"\"\"Base game over Exception.\"\"\"\n    pass\n\nclass AntsWinException(GameOverException):\n    \"\"\"Exception to signal that the ants win.\"\"\"\n    pass\n\nclass BeesWinException(GameOverException):\n    \"\"\"Exception to signal that the bees win.\"\"\"\n    pass\n\ndef interactive_strategy(colony):\n    \"\"\"A strategy that starts an interactive session and lets the user make\n    changes to the colony.\n\n    For example, one might deploy a ThrowerAnt to the first tunnel by invoking\n    colony.deploy_ant('tunnel_0_0', 'Thrower')\n    \"\"\"\n    print('colony: ' + str(colony))\n    msg = '<Control>-D (<Control>-Z <Enter> on Windows) completes a turn.\\n'\n    interact(msg)\n\ndef start_with_strategy(args, strategy):\n    \"\"\"Reads command-line arguments and starts a game with those options.\"\"\"\n    import argparse\n    parser = argparse.ArgumentParser(description=\"Play Ants vs. SomeBees\")\n    parser.add_argument('-d', type=str, metavar='DIFFICULTY',\n                        help='sets difficulty of game (easy/medium/hard/insane)')\n    parser.add_argument('-w', '--water', action='store_true',\n                        help='loads a full layout with water')\n    parser.add_argument('--food', type=int,\n                        help='number of food to start with when testing', default=2)\n    args = parser.parse_args()\n\n    assault_plan = make_test_assault_plan()\n    layout = dry_layout\n    tunnel_length = 9\n    num_tunnels = 1\n    food = args.food\n\n    if args.water:\n        layout = wet_layout\n    if args.d in ['e', 'easy']:\n        assault_plan = make_easy_assault_plan()\n        num_tunnels = 2\n        food = 2\n    elif args.d in ['n', 'normal']:\n        assault_plan = make_normal_assault_plan()\n        num_tunnels = 3\n        food = 2\n    elif args.d in ['h', 'hard']:\n        assault_plan = make_hard_assault_plan()\n        num_tunnels = 4\n        food = 2\n    elif args.d in ['i', 'insane']:\n        assault_plan = make_insane_assault_plan()\n        num_tunnels = 4\n        food = 2\n\n    hive = Hive(assault_plan)\n    dimensions = (num_tunnels, tunnel_length)\n    return AntColony(strategy, hive, ant_types(), layout, dimensions, food).simulate()\n\n\n###########\n# Layouts #\n###########\n\ndef wet_layout(queen, register_place, tunnels=3, length=9, moat_frequency=3):\n    \"\"\"Register a mix of wet and and dry places.\"\"\"\n    for tunnel in range(tunnels):\n        exit = queen\n        for step in range(length):\n            if moat_frequency != 0 and (step + 1) % moat_frequency == 0:\n                exit = Water('water_{0}_{1}'.format(tunnel, step), exit)\n            else:\n                exit = Place('tunnel_{0}_{1}'.format(tunnel, step), exit)\n            register_place(exit, step == length - 1)\n\ndef dry_layout(queen, register_place, tunnels=3, length=9):\n    \"\"\"Register dry tunnels.\"\"\"\n    wet_layout(queen, register_place, tunnels, length, 0)\n\n\n#################\n# Assault Plans #\n#################\n\nclass AssaultPlan(dict):\n    \"\"\"The Bees' plan of attack for the Colony.  Attacks come in timed waves.\n\n    An AssaultPlan is a dictionary from times (int) to waves (list of Bees).\n\n    >>> AssaultPlan().add_wave(4, 2)\n    {4: [Bee(3, None), Bee(3, None)]}\n    \"\"\"\n\n    def add_wave(self, bee_type, bee_armor, time, count):\n        \"\"\"Add a wave at time with count Bees that have the specified armor.\"\"\"\n        bees = [bee_type(bee_armor) for _ in range(count)]\n        self.setdefault(time, []).extend(bees)\n        return self\n\n    @property\n    def all_bees(self):\n        \"\"\"Place all Bees in the hive and return the list of Bees.\"\"\"\n        return [bee for wave in self.values() for bee in wave]\n\ndef make_test_assault_plan():\n    return AssaultPlan().add_wave(Bee, 3, 2, 1).add_wave(Bee, 3, 3, 1)\n\ndef make_easy_assault_plan():\n    plan = AssaultPlan()\n    for time in range(3, 16, 2):\n        plan.add_wave(Bee, 3, time, 1)\n    plan.add_wave(Wasp, 3, 4, 1)\n    plan.add_wave(NinjaBee, 3, 8, 1)\n    plan.add_wave(Hornet, 3, 12, 1)\n    plan.add_wave(Boss, 15, 16, 1)\n    return plan\n\ndef make_normal_assault_plan():\n    plan = AssaultPlan()\n    for time in range(3, 16, 2):\n        plan.add_wave(Bee, 3, time, 2)\n    plan.add_wave(Wasp, 3, 4, 1)\n    plan.add_wave(NinjaBee, 3, 8, 1)\n    plan.add_wave(Hornet, 3, 12, 1)\n    plan.add_wave(Wasp, 3, 16, 1)\n\n    #Boss Stage\n    for time in range(21, 30, 2):\n        plan.add_wave(Bee, 3, time, 2)\n    plan.add_wave(Wasp, 3, 22, 2)\n    plan.add_wave(Hornet, 3, 24, 2)\n    plan.add_wave(NinjaBee, 3, 26, 2)\n    plan.add_wave(Hornet, 3, 28, 2)\n    plan.add_wave(Boss, 20, 30, 1)\n    return plan\n\ndef make_hard_assault_plan():\n    plan = AssaultPlan()\n    for time in range(3, 16, 2):\n        plan.add_wave(Bee, 4, time, 2)\n    plan.add_wave(Hornet, 4, 4, 2)\n    plan.add_wave(Wasp, 4, 8, 2)\n    plan.add_wave(NinjaBee, 4, 12, 2)\n    plan.add_wave(Wasp, 4, 16, 2)\n\n    #Boss Stage\n    for time in range(21, 30, 2):\n        plan.add_wave(Bee, 4, time, 3)\n    plan.add_wave(Wasp, 4, 22, 2)\n    plan.add_wave(Hornet, 4, 24, 2)\n    plan.add_wave(NinjaBee, 4, 26, 2)\n    plan.add_wave(Hornet, 4, 28, 2)\n    plan.add_wave(Boss, 30, 30, 1)\n    return plan\n\ndef make_insane_assault_plan():\n    plan = AssaultPlan()\n    plan.add_wave(Hornet, 5, 2, 2)\n    for time in range(3, 16, 2):\n        plan.add_wave(Bee, 5, time, 2)\n    plan.add_wave(Hornet, 5, 4, 2)\n    plan.add_wave(Wasp, 5, 8, 2)\n    plan.add_wave(NinjaBee, 5, 12, 2)\n    plan.add_wave(Wasp, 5, 16, 2)\n\n    #Boss Stage\n    for time in range(21, 30, 2):\n        plan.add_wave(Bee, 5, time, 3)\n    plan.add_wave(Wasp, 5, 22, 2)\n    plan.add_wave(Hornet, 5, 24, 2)\n    plan.add_wave(NinjaBee, 5, 26, 2)\n    plan.add_wave(Hornet, 5, 28, 2)\n    plan.add_wave(Boss, 30, 30, 2)\n    return plan\n\n\nfrom utils import *\n@main\ndef run(*args):\n    Insect.reduce_armor = class_method_wrapper(Insect.reduce_armor,\n            pre=print_expired_insects)\n    start_with_strategy(args, interactive_strategy)\n\n",
            "group_members_6144637251092480.json": "{\n    \"0\": \"rosachoe@berkeley.edu\",\n    \"1\": \"djara96@berkeley.edu\"\n}",
            "group_meta_6144637251092480.json": "{\n    \"assignment\": {\n        \"active\": true,\n        \"autograding_enabled\": false,\n        \"autograding_key\": \"\",\n        \"course\": {\n            \"active\": true,\n            \"created\": \"2015-08-24 20:37:42.000000\",\n            \"display_name\": \"CS 61A\",\n            \"id\": 5631829415559168,\n            \"institution\": \"UC Berkeley\",\n            \"instructor\": [],\n            \"offering\": \"cal/cs61a/fa15\"\n        },\n        \"created\": \"2015-10-06 15:04:15.703590\",\n        \"creator\": {\n            \"created\": \"2015-01-24 09:31:51.000000\",\n            \"email\": [\n                \"denero@berkeley.edu\"\n            ],\n            \"id\": 5937555576979456,\n            \"is_admin\": true\n        },\n        \"display_name\": \"Ants\",\n        \"due_date\": \"2015-10-16 23:59:59.000000\",\n        \"id\": 5474163168903168,\n        \"lock_date\": \"2015-10-20 23:59:59.000000\",\n        \"max_group_size\": 2,\n        \"name\": \"cal/cs61a/fa15/proj3\",\n        \"points\": 25.0,\n        \"revision\": false,\n        \"templates\": \"{}\",\n        \"url\": \"cs61a.org/proj/ants\"\n    },\n    \"created\": \"2015-10-08 18:37:44.951080\",\n    \"id\": 6144637251092480,\n    \"invited\": [],\n    \"member\": [\n        {\n            \"created\": \"2015-08-26 00:12:57.640360\",\n            \"email\": [\n                \"rosachoe@berkeley.edu\"\n            ],\n            \"id\": 5622994265178112,\n            \"is_admin\": false\n        },\n        {\n            \"created\": \"2015-06-22 15:37:21.127120\",\n            \"email\": [\n                \"djara96@berkeley.edu\"\n            ],\n            \"id\": 5585293436518400,\n            \"is_admin\": false\n        }\n    ],\n    \"order\": null\n}"
        },
        "grading": {
            "Problem 0": {
                "failed": 0,
                "locked": 0,
                "passed": 6
            },
            "Problem 1": {
                "failed": 0,
                "locked": 0,
                "passed": 3
            },
            "Problem 2": {
                "failed": 0,
                "locked": 0,
                "passed": 3
            },
            "Problem 3A": {
                "failed": 0,
                "locked": 0,
                "passed": 8
            },
            "Problem 3B": {
                "failed": 0,
                "locked": 0,
                "passed": 6
            },
            "Problem 4A": {
                "failed": 0,
                "locked": 0,
                "passed": 6
            },
            "Problem 4B": {
                "failed": 0,
                "locked": 0,
                "passed": 11
            },
            "Problem 5A": {
                "failed": 0,
                "locked": 0,
                "passed": 2
            },
            "Problem 5B": {
                "failed": 0,
                "locked": 0,
                "passed": 5
            },
            "Problem 6A": {
                "failed": 0,
                "locked": 0,
                "passed": 7
            },
            "Problem 6B": {
                "failed": 0,
                "locked": 0,
                "passed": 5
            },
            "Problem 7": {
                "failed": 0,
                "locked": 0,
                "passed": 14
            },
            "Problem 8": {
                "failed": 0,
                "locked": 0,
                "passed": 7
            },
            "Problem 9": {
                "failed": 0,
                "locked": 0,
                "passed": 9
            },
            "Problem EC": {
                "failed": 1,
                "locked": 0,
                "passed": 1
            }
        }
    },
    "server_time": "2015-10-12 19:49:38.670650",
    "submitter": {
        "created": "2015-08-26 00:12:57.640360",
        "email": [
            "rosachoe@berkeley.edu"
        ],
        "id": 5622994265178112,
        "is_admin": false
    },
    "tags": []
}